#+TITLE: A Simple Fast Hybrid Pattern-Matching Algorithm
#+DATE: <2013-12-08 Sun>
#+AUTHOR: Grégoire Jadi \and Noémi Salaün
#+EMAIL: daimrod@gmail.com
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not LOGBOOK) date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t toc:t todo:t |:t
#+CREATOR: Emacs 24.3.50.1 (Org mode 8.0.2)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: fr
#+SELECT_TAGS: export
#+STARTUP: latexpreview
#+STARTUP: entitiespretty


* Introduction
Dans leur papier, F. Franek, C. G. Jennings et W. F. Smyth présentent
une nouvelle approche au problème de recherche de chaîne exacte dans
un texte.

Ce problème, bien connu et déjà largement étudié dans la littérature
informatique, est le suivant:

#+BEGIN_QUOTE
Soit un texte T de longueur n et un motif P de longueur m tous deux
écrit dans un alphabet \Sigma de taille k, on cherche toutes les occurences
exactes du motif dans le texte.
#+END_QUOTE

À l'origine, deux papiers définissant deux algorithmes posent les
bases sur lesquelles de nombreuses variations ont été construites,
dont l'algorithme FJS décrit dans l'article étudié. Ces deux
algorithmes sont l'algorithme Knut-Morris-Pratt (KMP) et l'algorithme
Boyer-Moore (BM).

Comme dit précédemment, les algorithmes KMP et BM appartiennent à la
grande famille des algorithmes résolvant le problème de recherche de
motif. De part leur manière d'aborder ce problème, on dit qu'ils
appartiennent à la sous-famille des algorithmes basés sur la
reconnaissance de caractères. 

Les autres approches communément employées sont les algorithmes basés
sur automates déterministes, et les algorithmes basés sur le
parallélisme de bits simulant des automates non-déterministes.

À première vu, on pourrait se demander pourquoi il existe autant de
variations autour du même problème, clairement défini, alors que les
limites théoriques sont déjà connues.

Cela tient au fait que ces algorithmes sont très utilisés dans des
conditions différentes, que ce soit en Traitement Automatique des
Langues afin de rechercher un mot dans un texte en langage naturel, ou
en Bio-Informatique afin de rechercher une séquence de gène dans
l'ADN.

Selon le cas d'utilisation, la taille des motifs recherchés et la
taille de l'alphabet vont varier. Or, ceux sont deux critères qui
peuvent grandement influencer l'efficacité des algorithmes.

Enfin, au vu des progrès fait dans la conception des CPUs, en
particulier l'accumulation de CPUs dans une même machine, fait que
certaines approches qui n'étaient pas intéressantes sur des machines
mono-CPU, deviennent très intéressantes, car facilement
parallélisable, sur des machines multi-CPUs.

* KMP et BM
Comme la plupart des algorithmes de recherche de chaîne, les
algorithmes KMP et BM effectuent un pré-traitement sur le motif. Le
but est d'extraire le maximum d'informations afin d'accélérer la
recherche du motif en minimisant le nombre de comparaison de
caractères.

** Knuth-Morris-Pratt
Le pré-traitement de l'algorithme KMP vise à extraire les sous-chaînes
les plus longues du motif qui s'aligne avec un préfixe du motif. Par
exmple dans le motif "ABCDABD", on remarque que la sous-chaînes "AB"
se trouve en ~P[1..2]~ et en ~P[5..6]~. Cette information permet de ne
pas reprendre la recherche à zéro si une comparaison échoue en ~P[7]~.

« more example »
** Boyer-Moore
Bien que le motif avance de gauche à droite, l'algorithme BM compare
le motif de droite à gauche, contrairement à l'algorithme KMP qui le
comparait de gauche à droite. Cette particularité permet à
l'algorithme BM de ne pas avoir à comporer tous les caractères du
texte dans certain cas.

« more example »

** Conclusion


* Présentation de l'algorithme FJS

* Présentation et explication des résultats

* Améliorations et variantes autour de FJS

* Back to the Future POV
